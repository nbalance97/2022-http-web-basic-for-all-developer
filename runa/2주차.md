# HTTP 기본

## 모든것이 HTTP

### HTTP란?

> Hyper Text Transfer Protocol

HTTP 메시지에 모든 것을 전송하며, 거의 모든 형태의 데이터를 전송할 수 있다.

서버간에 데이터를 주고받을 때도 대부분 HTTP를 사용하게 된다.

→ 지금은 HTTP 시대!

### HTTP 역사

**HTTP/1.1** → 가장 많이 사용하며, 가장 중요한 버전

HTTP/2 → 성능개선

HTTP/3 → TCP 대신 UDP(속도 최적화), 성능개선

- **TCP** 통신은 **3 way handshake** 때문에 신뢰성과 연결성은 보장하지만, 이 과정에 걸리는 시간만큼 속도가 떨어질 수 밖에 없다. 그렇기에 HTTP/3에서는 **UDP** 프로토콜을
  애플리케이션 레벨에서 재설계를 해서 속도를 높혔다

## 특징

### 1. 클라이언트 서버구조

클라이언트는 요청(Request)을 보내고 서버는 요청에 대한 결과를 응답(Response)하는 구조

과거에는 클라이언트와 서버가 하나로 뭉쳐있었으나, 위와 같이 서버와 클라이언트가 분리되면서 각각 독립적으로 발전할 수 있게 되었다.

따라서 클라이언트는 UI나 UX에 집중하고, 서버는 데이터나 백엔드 로직에 집중할 수 있다. 또한, 에러가 발생하였을 시에도 해당 부분만 수정하면 되는 장점이 생긴다.

### 무상태 프로토콜 (Stateless)

> 서버가 클라이언트의 상태를 보존하지 않는다.


**장점** : 서버 확장성이 높음

**단점 :** 클라이언트가 추가적인 데이터를 전송함

- **상태유지:**  서버가 클라이언크의 상태를 보존한다
    - 항상 같은 서버가 유지되어야한다.
    - 서버가 중간에 장애가 발생하면 처음부터 다시 해야된다.
- **무상태:** 서버가 클라이언트의 상태를 보존하지 않는다.
    - 중간에 서버가 에러가 나더라도 다른 서버에서 처리 가능.
    - 서버 증설에 유리하다. (스케일 아웃)

**한계**

- 모든 것을 무상태로 설계할 수 있는 경우도 있으나, 없는 경우도 있다.
    - ex) 로그인
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해 상태를 유지하며, 이러한 상태유지는 최소한만 사용하게 된다.
- 전송되는 데이터의 양이 많다.

그러나, 최대한 무상태를 사용하고, 상태의 경우 최소화하는 것이 좋다.

### 비연결성

- 연결 유지 모델 → 연결이 유지되므로 서버 자원이 계속 소모된다.
- 비연결 모델 → 서버의 연결 유지 X, 서버가 최소한의 자원 사용

HTTP는 기본적으로 연결을 유지하지 않는 모델.

- 1시간동안 수천명이 서비스를 사용하더라도 실제 서버에서 동시에 처리하는 요청은 수십개 이하.
- 서버 자원을 매우 효과적으로 사용할 수 있음

**단점**

- 매번 새로 TCP/IP연결을 맺어야 함 → 3 way handshake 시간 추가
- 웹 브라우저로 사이트 요청 → HTML + js, css, img ... 많은 것들이 추가적으로 다운로드됨.

![img.png](2주차%20img/img.png)

→ HTTP 지속 연결 (**Persistent Connection**)으로 문제 해결! (2, 3에서는 더 최적화)

![img_1.png](2주차%20img/img_1.png)

- 클라이언트와 서버가 연결을 한 뒤 필요한 자원을 요청/응답으로 다운받는다.

- 각각의 자원이 별도의 연결/종료가 되는 것이 아니라 한 연결에 필요 정보를 모두 다운받은 뒤 종료된다. 그럼으로써 연결/종료에 걸리는 시간을 단축할 수 있다.

**스테이트리스를 기억하자!**

- 딱 같은 시간에 발생하는 대용량 트래픽
- EX) 선착순 이벤트, 명절 KTX, 선착순 치킨 이벤트

최대한 무상태를 유지하는 것이 좋다. → 이런 상황에서도 확장할 수 있도록.

### HTTP 메시지 구조

![img_3.png](2주차%20img/img_3.png)

1. **start-line :** 요청 혹은 응답의 자원(혹은 상태)이 작성되는 공간

```    
Request-line
    Format : [method]SP[request-target]SP[HTTP-version]CRLF
    Ex     : GET /search?q=hello&hl=ko HTTP/1.1
```

```    
Status-Line
    Format : [HTTP-version]SP[status-code]SP[reason-phrase]
    Ex     : HTTP/1.1 200 OK
```

2. HTTP 헤더 : HTTP 전송에 필요한 모든 부가정보 제공
    - Ex: 메세지 바디의 내용 및 크기정보, 압축,인증, 요청(브라우저)정보 등
    - 표준 헤더도 많으며, 임의의 헤더도 추가할 수 있음

```
HTTP Header
    Format : [header-field]:[field-value]
    Ex     : Content-Type: application/json

```

3. empty line (CRLF) : 공백(Enter), Message Body와 구분하는 역할
4. HTTP Message Body : 실제 전송할 데이터
    - HTML 문서, 이미지, 영상, JSON 기타 byte로 표현가능한 모든 데이터

HTTP는 단순하고, 확장성이 넓다.

---

# HTTP 메서드

## HTTP URI

URI설계 시 가장 중요한 것은 리소스 식별이다.

리소스와 해당 리소스를 대상으로 하는 행위를 분리해야 한다.

- 리소스 : 동작을 제외한 자원 그 자체
    - 계층 구조상 상위를 컬렉션으로 보고 복수 단어 사용 권장 (member → members)
- 행위 : 조회, 등록, 삭제, 변경 → HTTP 메서드
- 리소스 = 명사, 행위 = 동사

## HTTP 메서드

![img.png](2주차%20img/img4.png)

### GET

- 리소스 조회
- 서버에 전달하고 싶은 데이터는query(쿼리 파라미터, 쿼리 스트링)를 통해 전달
- 메시지 바디를 사용해 데이터를 전달할 수 있으나, 지원하지 않는 곳이 많아서 권장하지 않는다.

### POST

- 메시지 바디를 통해 서버로 요청 데이터 전달 → 데이터를 처리
- 서버는 요청 데이터를 처리
    - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
    - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 됨 = 정해진건 X
- 요청데이터를 어떻게 처리할 지 리소스마다 조금씩 달라질 수 있음.
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
    - 새 리소스 생성(등록)
    - 요청 데이터 처리
        - 단순히 데이터를 생성하거나 변경하는 것을 넘어 프로세스를 처리해야 되는 경우
        - (ex- 결제 완료 → 배달 시작 → 배달 완료처럼 상태가 변경되는 경우)
        - POST /orders/{orderId}/start-delivery (동사형 URI - 컨트롤 URI)
    - 다른 메서드로 처리하기 애매한 경우
        - EX) JSON으로 조회 데이터를 넘겨야하는데 GET 메서드를 사용하기 어려운 경우 (다만 이 경우엔 GET을 쓰는게 좋다.)

### PUT

- 리소스를 완전히 대체한다
    - 리소스가 있으면 대체, 리소스가 없으면 생성
    - 완전히 덮어쓰게 된다.
- 클라이언트가 리소스를 식별함
    - 클라이언트가 리소스 위치를 알고 URI를 지정
    - POST와의 차이점

### PATCH

- 리소스 부분 변경

### DELETE

- 리소스 삭제

### 기타

- HEAD: GET이랑 동일하지만 메시지 제외하고 상태 줄과 헤더만
- OPTIONS: 해당 리소스에 대한 통신 가능 옵션 (메서드) 설명 (주로 CORS)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
- CONNECT, TRACE → 거의 사용하지 않음

## HTTP 메서드의 속성

### 안전(Safe)

- 호출해도 리소스를 변경하지 않는다. (GET, HEAD)
- 리소스만 고려하므로 로그와 같은 부분은 고려 X

### 멱등(Idempotent)

- 1번 호출하든 100번 호출하든 결과가 같다.
    - 외부 요인으로 중간에 리소스가 변경되는 것은 고려 X
- 멱등 메서드
    - GET: 조회
    - PUT: 결과를 대체 → 같은 요청을 여러번 해도 최종 결과는 같음
    - DELETE: 결과를 삭제 → 같은 요청을 여러번 해도 결과는 같음
    - **POST** : 멱등 X → 여러번 호출하면 같은 결제가 중복해서 일어날 수 있음.
- 활용
    - 자동 복구 매커니즘

### 캐시가능(Cacheable)

- 응답결과 리소스를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH 캐시 가능
    - 실제로는 GET, HEAD만
    - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 함 → 구현이 어려움

# 공유하고 싶은 내용

- queryParameter와 pathVariable은 어떤 기준에서 나누어 URI를 설계하면 좋을까?
- 멱등성을 고려하는 것이 유연한 개발에 많은 도움이 되는 것일까? (한번 삭제된 이후에 다시 삭제하면 에러가 발생하는 로직이라면, 멱등이 발생하지 않는 것일까?)