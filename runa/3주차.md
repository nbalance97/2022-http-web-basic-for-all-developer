# HTTP 메서드 활용

### 쿼리 파라미터를 통한 데이터 전송

- GET에서 많이 사용, 정렬 필터나 검색기능

### 메시지 바디를 통한 데이터 전송

- POST, PUT, PATCH 등 리소스를 등록 및 수정하는데 사용

### 정적 데이터 조회

- 조회이므로 GET 사용, 리소스 경로로 단순하게 조회

### 동적 데이터 조회

`https://www.inflearn.com/course/http-웹-네트워크/lecture/61368?tab=note&volume=1.00&speed=1.25`

- 조회조건을 줄어주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
- 조회이므로 GET 사용, 쿼리 파라미터로 데이터 전송

### HTML Form 데이터 전송

- Form submit 시에는 POST 전송하지만, GET 전송도 가능 (GET시 url에 쿼리 파라미터로 들어옴)
- Content-Type : `application/x-www-form-urlencoded`
    - form의 내용을 메시지 바디를 통해 전송 (key = value, 쿼리 파라미터 형식)
    - 전송데이터를 url 인코딩
- Content-Type : `multipart/form-data`
    - 파일 업로드와 같은 바이너리 데이터 전송시 사용
    - 다른 여러 종류의 파일과 폼의 내용 함께 전송 가능

### HTTP API 데이터 전송

- 서버 to 서버 : 백엔드 시스템 통신
- 앱 클라이언트, 웹 클라이언트 (AJAX)
- HTML 메서드
    - POST, PUT, PATCH → 메시지 바디를 통해 데이터 전송 가능
    - GET → 조회, 쿼리 파라미터로 데이터 전달
- Content-Type : application/json을 주로 사용

## HTTP API 설계 예시

URI는 리소스를 식별해야지, 다른걸 식별해서는 안된다. (행위는 HTTP 메서드로 표현한다.)

수정하는 것은 왠만하면 PATCH를 쓰는게 좋음. (PUT은 아예 덮어쓰는 것이니까.) 애매하면 POST

PUT 기반 등록과 POST 기반의 등록을 구분하는 것이 중요하다.

### POST - 신규자원 등록 특징

- 클라이언트는 등록된 URI를 **모른다**
- 서버는 새로 등록된 리소스 URI를 **생성해준다**
- 컬렉션(Collection) : 서버가 관리하는 리소스 데렉토리
    - 서버가 리소스의 URI를 생성 및 관리 (EX. /members)

*→ POST 기반의 Collection을 대부분 사용한다.*

### Put - 신규 자원 등록 특징

파일 관리 시스템을 예시로 삼는 것이 좋다.

- 클라이언트가 리소스 URI를 알고 있어서 **직접 지정한다**.
    - 파일 등록 /files/{file-name} → PUT
- 스토어(Store) : 클라이언트가 관리하는 리소스 저장소
    - 클라이언트가 리소스의 URI 를 알고 관리. (EX. /files)

### HTML FORM 사용

- HTML FORM은 **GET과 POST**만 지원 → 제약이 있음
- 컨트롤 URI : 위 문제의 해결책 (HTTP 메서드로 행위를 다 표현하지 못할 때 사용)
    - 동사로 된 URI 사용
    - ex) POST의 /new, /edit, /delete
    - 실무에서는 HTTP 메서드로 다 표현하기 어려운게 많아서 컨트롤 URI 많이 사용
    - 불가피하여 사용하는 것이지, 최대한 HTTP 메서드로 표현하는 것이 좋다.

등록 폼과 등록은 같은 URI를 사용하는 것을 영한님은 추천!

폼 자체를 보는건 GET, 폼을 작성해서 전송하는건 POST

### 좋은 URI 개념

[추천 링크](https://restfulapi.net/resource-naming/)

- **문서(Document)**
    - 단일 개념 (ex - /members/100)
- **컬렉션(Collection) :** 서버가 관리하는 리소스 디렉터리
    - 서버가 리소스의 uri를 생성 및 관리
    - ex - /members
- **스토어(Store) :** 클라이언트가 관리하는 자원 저장소
    - 클라이언트가 리소스의 uri를 알고 관리
    - ex - /files
- **컨트롤러(Controller), 컨트롤 URI**
    - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    - 동사를 사용하며 리소스의 행위 사용
    - 컬렉션, 문서로 최선을 다하다가 안되면 컨트롤 URI
    - ex - /members/{id}/delete

---

# HTTP 상태코드

상태코드 : 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

모르는 (클라이언트가 인식할 수 없는) 상태코드가 나타난다면?

- 299 → 2xx 과 같이 상위 상태코드로 해석하여 처리함.
- 미래에 새로운 상태코드가 추가되더라도 클라이언트를 변경하지 않아도 됨.

## 1xx (Informational)

> 요청이 수신되어 처리중
>

- 거의 사용하지 않는다.

## 2xx (Successful)

> 클라이언트의 요청을 성공적으로 처리
>

- **200 OK :** 응답이 성공한 경우
- **201 CREATED :** 리소스가 정상적으로 생성된 경우
    - 생성된 리소스는 응답의 `Location` 헤더 필드로 식별
- **202 Accepted :** 접수는 되었으나 처리되지는 않음
    - 배치 처리 같은 곳에서 사용. (ex - 접수 요청 1시간 뒤 요청 처리)
- **204 No Content** : 요청은 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
    - ex) 웹 문서 편집기에서 save 버튼 (눌러도 내용이나 화면변화 X)

      → 내용이 없어도 204 메시지만으로 성공을 인식할 수 있다.

→ 200이랑 201정도만 쓰자 라고 범위를 잡고 사용하는 것이 좋다.

## 3xx (Redirection)

> 요청을 완료하기 위해서 유저 에이전트(클라이언트)의 추가 조치 필요
>

웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동 이동한다 (= 리다이렉트)

### **영구 리다이렉션**

- 특정 리소스의 URI가 영구적으로 이동. (원래의 URL을 사용 X, 검색 엔진 등에서도 변경 인지)
- **301 Moved Permanently**
    - 리다이렉트 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음

  → 과거 스펙에서는 변경 X를 의도했으나 바뀌었다.

- **308 Permanently**
    - 301과 기능은 같음. 리다이렉트시 요청 메서드와 본문 유지.

### **일시 리다이렉션**

- 일시적인 변경 (ex- 주문 완료 후 주문 내역 화면으로 이동)
- 일시적인 변경이므로 검색 엔진 등에서 URL을 변경하면 안됨
- **302 Found**
    - 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음. (높은 확률로 변함)

      → 명확하지 않아서 아래 두 코드가 추가됨

- **307 Temporary Redirect**
    - 302와 기능은 같음. 리다이렉트시 요청 메서드와 본문 유지
- **303 See Other**
    - 302와 기능은 같으나 요청 메서드가 GET으로 변경

명확하게 303이나 307로 하는 것을 추천하지만, 실무에서는 302도 많이 쓴다.

- **PRG (Post Redirect Get) Pattern**
    - POST로 주문후에 웹 브라우저를 새로고침하면?

      → 새로고침은 다시 요청 = 중복 주문이 될 수 있다.

    - **POST**로 구매 요청 → **REDIRECTION** 응답 받음 → **GET**으로 리다이렉션 링크 조회 → 결과 받음

      → 결과 화면에서 새로고침이 되더라도 그냥 GET으로 리다이렉션 링크 조회 됨

### **특수 리다이렉션**

- 결과 대신 캐시를 사용

### **기타 리다이렉션**

- 300 Multiple Choices → 안쓴다
- 304 Not Modified : 캐시를 목적으로 사용
    - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다)
    - 응답에 메시지 바디를 포함하면 안된다 (로컬 캐시를 사용해야 하므로)
    - 조건부 GET, HEAD 요청시 사용

## 4xx (Client Error)

> 클라이언트 오류 (오류의 원인이 클라이언트에 있음)
>

클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함.

- 400 Bad Request
    - 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
    - 요청 구문, 메시지 등이 오류 → 클라이언트는 요청 내용을 다시 검토하고 보내야 함.
- 401 Unauthorized
    - 인증되지 않음
    - 오류 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
    - 참고
        - 인증(Authentication) : 본인이 누구인지 확인, 로그인
        - 인가(Authorization): 권한 부여
        - 오류 메시지가 Unauthorized이지만, 인증되지 않음.
- 403 Forbidden
    - 서버가 요청을 이해했지만 승인을 거부함
    - 주로 인증 자격 증명은 있지만(로그인은 됨), 접근 권한이 불충분한 경우
- 404 Not Found
    - 요청 리소스를 찾을 수 없거나, 클라이언트가 권한이 부족한 리소스에 접근하였지만 리소스를 숨기고 싶을 때

## 5xx (Server Error)

> 서버 오류 (서버에 문제가 있으므로 재시도하면 해결될 수도 있음)
>

- 500 Internal Server Error
    - 서버 내부의 문제로 오류 발생. 애매하면 500
- 503 Service Unavailable
    - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음.

→ 왠만하면 서버 에러를 안만드는 것이 좋다. 진짜 서버 에러가 발생하였을 때에만.

### 공유하고 싶은 내용

- [상태코드의 결정 관련된 좋은 결정 트리](https://stackoverflow.com/questions/39636795/http-status-code-4xx-vs-5xx)