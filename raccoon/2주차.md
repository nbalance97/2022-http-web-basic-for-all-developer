### HTTP

- HyperText Transfer Protocol
- HTTP 메시지에 모든 것을 전송
    - html, text 뿐 아니라 이미지, 음성, 영상, 파일, json, xml
    - 서버 간에 데이터를 주고 받을 때도 대부분 http 사용
    - 거의 모든 형태의 데이터 전송 가능

### HTTP의 역사

---

- HTTP 1.1 : 가장 많이 사용, 가장 중요
    - RFC2068 → RFC2616 → RFC 7230~7235로 개정
- HTTP 2 : 성능 개선
- HTTP 3 : 진행중, tcp 대신 udp, 성능 개선

### 기반 프로토콜

---

- TCP : HTTP/1.1, HTTP/2
- UDP : HTTP/3
    - 3-way handshake, tcp가 빠르지 않는 단점으로 인해 애플리케이션 레벨에서 빠르게 설계
- 현재는 HTTP 1.1을 주로 사용, HTTP 2와 HTTP 3은 점점 증가

### HTTP의 특징

---

1. 클라이언트-서버 구조
    - Request - Response 구조
    - 클라이언트는 서버에 요청을 보내고 응답 대기
    - 서버가 요청에 대한 결과를 만들어서 응답
    - 비즈니스 로직이나 데이터를 서버에 몰아넣고, 클라이언트는 ui 등 사용성에 집중
        
        ⇒ 클라이언트가 복잡한 비즈니스 로직이나 복잡한 데이터를 다룰 필요가 없음. ui 등 사용성에 집중
        
        ⇒ 트래픽 등 서버의 문제는 클라이언트를 신경 쓸 필요 없이 서버에 초점을 맞출 수 있음.
        
2. 무상태 프로토콜(스테이스리스), 비연결성
    
    ### 무상태 프로토콜(stateless)
    
    - 서버가 클라이언트의 상태를 보존하지 않는다.
        - 서버 확장성이 높음
    - 상태 유지(Stateful)
        - 구매 물건 → 개수 → 결제 수단 → 결제
        - 각 단계별로 (구매 물건) 상태 유지, (구매 물건, 개수) 상태 유지, (구매 물건, 개수, 결제 수단) 상태 유지
        - 중간에 점원이 바뀐다면?  장애가 발생한다.
            - 어떤 물건을 2개 구매하나요?
            - 어떤 물건을 몇개 신용카드로 구매하나요?
        - 항상 `같은 서버가 유지`되어야 한다.
            - 중간에 장애가 온 경우, 클라이언트는 처음부터 다시 통신해주어야 한다.
    - 무상태(Stateless)
        1. 노트북 얼마인가요?
        2. 노트북 2개 구매하겠습니다
        3. 노트북 2개를 신용카드로 구매하겠습니다.
        - 고객이 필요한 데이터를 모두 점원에게 넘기기 때문에 중간에 점원이 바뀌더라도 문제가 없다.
        - 스케일 아웃(수평 확장)에 유리 → 장비를 수십대 수백대 늘릴 수 있다.
        
        단점)
        
        1. 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
        2. `서비스 소개 화면 → 무상태`, `로그인 → 상태 유지`의 필요성이 있음.
            - 로그인 했다는 상태를 서버에 유지
            - 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
            - 상태 유지는 `최소한`만 사용, 꼭 필요한 경우에만 어쩔수 없이 사용
        3. 데이터를 많이 보내야 한다는 문제가 있음
        4. 설계 시 `최대한 무상태로 설계`해야 하며, 어쩔수 없는 경우에는 최소한의 상태 유지
    - Stateful vs Stateless
        - 상태 유지 : 중간에 다른 점원으로 바뀌면 안됨.
        - 무상태 : 중간에 다른 점원으로 바뀌어도 된다.
            - 갑자기 고객이 증가해도 점원을 대거 투입 가능
            - 갑자기 클라이언트 요청이 증가하더라도 서버를 대거 투입 가능
        - 무상태는 응답 서버를 쉽게 바꿀 수 있다 → 무한한 서버 증설 가능
    - 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
        - 저녁 6:00 선착순 1000명 치킨 할인 이벤트 → 수만명이 동시에 요청
        - 어떻게든 stateless로 설계해야 서버를 쉽게 확대할 수 있음.
    
    ### 비 연결성
    
    - TCP 연결 → 요청 → 응답 이후 TCP 연결을 끊어버림
        - 서버는 연결을 유지하지 않으며 최소한의 자원만을 유지한다.
    - HTTP는 기본이 연결을 유지하지 않는 모델
    - 일반적으로 초 단위의 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
        - 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않음.
    - 서버 자원을 매우 효율적으로 사용 가능
        
        ### 단점
        
        - TCP/IP 연결을 매번 새로 맺어야 함 - 3 way handshake 시간이 추가됨
        - 웹 브라우저로 사이트를 요청하면 html 뿐 아니라 js, css, 추가 이미지 등 수 많은 자원이 함께 다운로드.
        - HTTP 지속 연결(Persistent Connections)로 문제 해결
            - 초기 HTTP에서는 연결과 종료가 낭비됨. HTML 얻기위해 한번, JS 얻기위해 한번, CSS 얻기위해 한번.
            - 모든 자원을 받은 후에 종료하도록 지속 연결
        - HTTP/2, HTTP/3에서 더 많은 최적화
3. HTTP 메시지
    - HTTP 요청 메시지, HTTP 응답 메시지의 구조가 다름
    - HTTP 메시지 구조
        - 시작 라인(start-line)
        - 헤더(header)
        - 공백 라인(empty line)
        - message body
    - 요청 메시지
        - 시작 라인 : `METHOD` `PATH` `HTTP버전`
            
            ### Method
            
            - GET, POST, PUT, DELETE 등등
            - 서버가 수행해야 할 동작 지정
                - GET: 리소스 조회
                - POST: 요청 내역 처리
            
            ### PATH
            
            - 절대경로[?쿼리]
            - 절대경로=”/”로 시작하는 경로
            
            ### HTTP Version
            
            - HTTP 버전
        - 헤더
        - Body가 없으면 공백 라인만 두고 끝내면 된다.
    - 응답 메시지
        - 요청 메시지와 시작 라인만 다름
        - 시작 라인 : **`HTTP버전`** **`응답코드`**(상태코드) **`이유 문구`**
            
            ### HTTP버전
            
            - HTTP 버전
            
            ### STATUS CODE
            
            - 요청 성공, 실패를 나타냄
            - 200: 성공
            - 400: 클라이언트 요청 오류
            - 500: 서버 내부 오류
            - 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글
        - 헤더
        - 공백라인
        - message body
    
    ### HTTP 헤더
    
    - 헤더 필드 = field-name “:” OWS field-value OWS (OWS: 띄어쓰기 허용)
    - field-name은 대소문자 구분 없음, value는 구분
    - HTTP 전송에 필요한 모든 부가정보
        - 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보 등등등
        - 표준 헤더가 너무 많음
        - 필요 시 임의의 헤더 추가 가능
            - 약속한 클라이언트나 서버만 이해 가능
    
    ### HTTP 메시지 바디
    
    - 실제 전송할 데이터
    - HTML 문서, 이미지, 영상, JSON 등 byte로 표현할수 있는 모든 데이터 전송 가능

1. 단순함, 확장 가능
    - HTTP는 단순하다. 스펙도 읽어볼만 하다
    - HTTP 메시지도 매우 단순
    - 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술
    

### HTTP 메서드

---

### 요구사항

- 회원 정보 관리 API를 만들어라.
    1. 회원 목록 조회(/read-member-list)
    2. 회원 조회(/read-member-by-id)
    3. 회원 등록(/create-member)
    4. 회원 수정(/update-member)
    5. 회원 삭제(/delete-member)

### API URI 고민

---

- 리소스의 의미는 뭘까?
    - 미네랄을 캐라 → 미네랄이 리소스
    - 회원이라는 개념 자체가 바로 리소스
- 리소스를 어떻게 식별하는게 좋을까?
    - 회원을 등록하고 수정하고 조회하는것을 모두 배제
    - 회원이라는 리소스만 식별 → 회원 리소스를 URI에 매핑
- 따라서, URI로는 회원 리소스를 표시
    - /members/{id}
    - 계층 구조상 `상위를 컬렉션`으로 보고 `복수단어 사용`을 권장

### HTTP 메서드

---

- 조회, 등록, 수정, 삭제가 모두 같은 리소스
- 리소스와 리소스를 대상으로 하는 행위를 분리
    - 리소스 : 회원 → 명사
    - 행위 : 조회, 등록, 삭제, 변경 → 동사

### HTTP 메서드의 종류

---

- `GET` : 리소스 조회
    - 리소스 조회
    - 서버에 전달하고자 하는 데이터는 `query(쿼리 파라메터, 쿼리 스트링)`를 통해서 전달
    - 메시지 바디를 통해서도 데이터를 전달할 수 있지만 지원하지 않는 서버가 많다.
    
- `POST`: 요청 데이터 처리, 주로 등록에 사용
    - 요청 데이터를 처리
    - 메시지 바디를 통해 서버로 요청 데이터 전달
    - 서버에서 요청 데이터 처리
        - 메세지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
    - 전달된 데이터로 `신규 리소스 등록`, `프로세스 처리`에 사용
    - 등록 시 201 Created, Location 헤더(자원이 생성된 path)를 보내 줌.
    - post 메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청
    - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함.
        1. 새 리소스 생성(등록)
        2. 요청 데이터 처리
            - 데이터 생성, 변경을 넘어 프로세스를 처리해야 하는 경우
            - 값 변경을 넘어 프로세스의 상태가 변경되는 경우
            - POST의 결과로 새 리소스가 생성되지 않을 수도 있음.
            - POST /orders/{orderId}/start-delivery
                
                → 동사의 uri를 control uri라고 함. 최대한 리소스로 uri를 설계하지만 어쩔수 없는 경우가 있음.
                
        3. 다른 메서드로 처리하기 애매한 경우
            - JSON으로 조회 데이터를 넘겨야 하는데, get 메서드를 사용하기 어려운 경우
                - message body를 허용하지 않는 경우가 많다.
            - 조회이지만 POST를 사용할 수 있음.
            - GET으로 오는 경우는 캐싱을 할 수 있지만, POST의 경우는 캐싱을 하기가 어려운 단점이 있다.
            
- `PUT`: 리소스를 대체, 해당 리소스가 없으면 생성
    - 리소스가 `있으면 대체, 없으면 생성`. 즉, 덮어버린다.
    - 클라이언트가 리소스를 식별
        - 클라이언트가 리소스 위치를 알고 URI 지정 (/members/100)
        - POST와의 차이점
    - 리소스를 완전히 대체한다.
        - username, age 필드가 있을때 age 필드만 넣을 수 없다.
        - age 필드만 넘기게 되면 username 필드가 사라지게 된다.
        
- `PATCH`: 리소스 부분 변경
    - 리소스 부분 변경
    - username, age 필드가 있을 때 age 필드만 수정 가능하다.
    - PATCH가 지원이 안되는 서버가 있을 수 있다. 그러한 경우는 POST를 사용해 주면 된다.
    
- `DELETE`: 리소스 삭제
    - 리소스 제거
    
- HEAD: GET과 동일하지만 메시지 부분을 제외하고 상태 줄과 헤더만 반환(body 빼고)
- OPTIONS: CORS에서 사용, 대상 리소스에 대한 통신 가능 옵션

### HTTP 메서드의 속성

1. `안전(Safe)`
    - 호출해도 **리소스를 변경하지 않는다.**
    - 그래도 계속 호출해서 로그 같은게 쌓여서 장애가 발생하면?
    - 안전은 `해당 리소스만 고려`한다. 그런 부분까지 고려하지 않는다.
2. `멱등(Idempotent)`
    - 한번 호출하던 두번 호출하던 백번 호출하던 결과가 같아야 한다.
    - 멱등 메서드
        - GET: 한번 조회하든, 두번 조회하든 같은 결과가 조회
        - PUT: 결과를 대체한다. 같은 요청을 여러번 해도 최종 결과는 같다.
        - DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
            - 최종적으로는 삭제된 상태 유지
        - POST: `멱등이 아니다.` 두번 호출하면 같은 결제가 중복해서 발생할 수 있다.
            - 두번 결제하면 중복 결제
    - 활용
        - 자동 복구 메커니즘
        - timeout 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 괜찮은가?
    - 재요청 중간에 다른 곳에서 리소스를 변경해 버린다면?
        - 사용자 1번 get → 사용자 2번 put → 사용자 1번 get
        - 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.
3. `캐시 가능(Cacheable)`
    - 응답 결과 리소스를 캐시해서 사용해도 되는가?
    - GET, HEAD, POST, PATCH는 캐시 가능
    - 실제로는 GET이나 HEAD 정도만 캐시로 사용
        - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는 문제, 구현이 어려움.

### 공유하고 싶은 내용

- HTTP 메서드
