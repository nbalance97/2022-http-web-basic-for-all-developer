### [1주차 포스팅](https://kth990303.tistory.com/311)

## 1. 인터넷 네트워크
### 프로토콜

- 통신을 하기 위한 일종의 약속. Internet Protocol
- Hello, world!를 전송하기 위해선 전송 데이터 뿐만 아니라 출발지 IP, 도착지 IP, 기타 내용들도 함께 패킷에 담겨있어야 요청/응답이 가능함.


### IP 프로토콜만의 한계
- 비연결성, 패킷을 받을 대상이 없거나 서비스 불능 상태일 때에도 패킷을 전송한다는 점.

- 비신뢰성, 중간에 패킷이 사라지거나 패킷이 순서대로 오지 않는 경우를 의미. 
  - 데이터를 일정 묶음으로 나눈 단위가 패킷이기 때문. 
  - Hello, world! 데이터를 전송할 때, Hello, 패킷의 크기가 너무 커서 전송속도가 world! 패킷보다 비교적 느리다면, 클라이언트의 의도와 다르게 서버쪽에선 world! Hello, 와 같은 데이터를 받을 위험이 존재. 그 외에 노드 장애, 다중 경로 라우팅으로 인한 패킷 유실 및 지연도착도 가능함.
  - (다만, ip header에 존재하는 fragment offset를 통해 수신 측에서 패킷의 순서 재조립, 추가데이터 여부 등은 확인이 가능하다고 하긴 함.)
- 프로그램 구분, 같은 IP에서 동시에 통신하는 애플리케이션이 존재할 때 발생할 수 있는 한계를 의미. 



### TCP, UDP

- 인터넷 프로토콜 계층
  - 애플리케이션 계층, 전송 계층(TCP, UDP), 인터넷 계층(IP), 네트워크 인터페이스 계층

- TCP 3-way handshake
  - 1. 클라이언트 -> 서버로 SYN을 보냄.
  - 2. 서버가 클라이언트 요청을 수락함과 동시에, 접속 요청을 함. SYN + ACK (서버 입장에선 서버가 클라이언트, 클라이언트가 서버임.)
  - 3. 클라이언트가 서버의 요청을 수락. ACK 
- 비신뢰성, 비연결성 문제가 사라지게 됨.
- 요즘은 최적화로 인해 3번 ACK를 보낼 때 데이터도 같이 보내준다고 함.

- TCP 4-way handshake
  - TCP 연결을 종료할 때에는 FIN, ACK, FIN, ACK를 주고받음.

- UDP
  - 사용자 데이터그램 프로토콜(User Datagram Protocol)
  - 데이터 전달 보증이나 순서 보장이 되지 않음.
  - 신뢰성이 보장돼야 하는 데이터를 보낼 때엔 TCP를, 간단한 데이터를 빠르게 보내고 싶을 때는 UDP를 사용
  - UDP에 별도의 최적화 및 추가작업을 하여 사용자 입맛에 맞게 사용할 수 있음. 이러한 점 덕분에 최근에 UDP가 각광받고 있다고 함.



### PORT
- 포트는 같은 IP 내에서 프로세스를 구분할 수 있도록 해준다.

- 웹서버 http의 경우 디폴트 포트번호가 80이고, https의 경우 디폴트 포트번호가 443이다.

- 실제로 kth990303.tistory.com:80 에 접속하거나 kth990303.tistory.com:443에 접속하면 잘 접속되나, https://kth990303.tistory.com:80 에접속하면 잘못된 응답이라며 에러가 발생한다.

- localhost:8080, 이 주소 뭔가 익숙하지 않은가? 톰캣같은 WAS 서버들은 보통 8080 포트를 사용하기 때문이다.

- 이처럼 tcp/ip 패킷에 ip와 포트번호까지 같이 존재하기 때문에 동일 IP에서의 여러 프로세스들 사이에서도 통신이 원활하게 가능하다.



### DNS
- 도메인 네임 시스템(DNS) 덕분에 우리는 IP 주소와 포트번호를 입력해서 통신하지 않고 도메인주소만 입력하면서 통신할 수 있다.

- 도메인 네임 서버에서 도메인과 IP, PORT를 매핑한 테이블을 제공해주기 때문이다. IP 주소는 기억하기 어렵기도 하고, 일부 변경이 일어날 수 있다는 단점들이 있었는데, 이를 DNS가 보완해준 것이다.

## 2. URI와 웹 브라우저 요청 흐름
### URI


- URL은 우리가 흔히 생각하는 도메인 주소 (kth990303.tistory.com/311)
- URN은 리소스의 이름 (kth990303의 코딩 블로그). 다만, URN만으로는 특정 리소스를 찾는 것이 불가능에 가깝기 때문에 URL, URI라는 개념을 훨씬 많이 사용한다. 

- URI는 식별의 개념에 가깝고, URL은 주소의 개념에 가깝다. 예를 들어 kth990303.tistory.com/index.html은 명확하게 확장자까지 나타내주는 주소이자, 다른 리소스들 사이에서 명확하게 식별이 가능하므로 URI, URL 둘 다 맞다. 그러나, kth990303.tistory.com/index는 식별은 가능하지만, 명확한 주소는 아니므로 URI는 맞지만 URL은 아니다. 서버에서 별도의 처리를 해주어 자동으로 .html 파일을 보여주긴 하지만, 엄밀히 존재하는 파일은 아니기 때문이다.

- URI가 좀 더 상위개념이라고 이해하면 편할 듯하다. 



### URL 문법

- 호스트명에는 주로 도메인 주소를 입력한다. 도메인 주소가 아닌 IP값을 입력해도 된다.

- https의 기본 포트번호는 443이며, 이는 생략이 가능하다. 그렇기 때문에 우리는 kth990303.tistory.com:443이 아닌 kth990303.tistory.com으로 바로 접속이 가능한 것이다.

- 패스(path)는 리소스 경로이다. 패스 뒤에 쿼리스트링이 존재할 수도 있다.



### 웹 브라우저 요청 흐름
1. 웹 브라우저에서 HTTP 요청 메시지를 생성. HTTP 요청 메시지에는 GET, POST와 같은 HTTP method, URI 등의 정보가 담겨있다.
2. SOCKET 라이브러리를 이용하여 커넥션을 TCP/IP로 맺게 하여, OS 계층에서 3-way handshake로 서버와 연결. 
3. OS의 TCP 계층에 왔으므로 TCP/IP 패킷을 생성해줌. 
4. 인터넷으로 요청 패킷을 보냄. 
5. 서버에 요청 패킷이 도착하게 되면 패킷 껍데기는 버리고 HTTP 요청 메시지를 서버에서 해석. 
6. 마지막으로, 서버에서 응답 패킷을 동일한 방식으로 클라이언트에게 보내주면 우리가 원하는 응답을 얻음.



## 느낀 점
- 애플리케이션 계층, OS 계층, 네트워크 인터페이스 계층을 통해 HTTP 메시지가 전달되는 과정을 조금이나마 알게 되서 만족스럽기도 하지만 조금 어렵기도 하다.
- IP, PORT, URI, URL에 대한 개념을 보다 명확하게 이해할 수 있어서 좋았다.
- DNS를 18학년도 6월 모평 국어 지문에서 봤을 때 무슨 소린지 몰랐는데, 여기서 보니까 보다 잘 이해되는 듯하다. 이 영상을 보고 모평을 봤다면 좋았을텐데 조금 아쉽다 ㅎㅎ
- 실무에서 UDP를 사용할 때, 어떠한 추가적인 최적화 및 작업을 해주는지 궁금하다. 아직 모르는 것, 배울 점들이 산더미인 듯.
- HTTP message, 빨리 배우고 싶다!
