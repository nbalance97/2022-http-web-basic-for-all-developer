
[편하게 보기](https://kth990303.tistory.com/319)

## 1. HTTP 기본

-  현재 우리가 가장 많이 사용하고 있는 것은 Http/1.1 버전이다. 
-  Http/2, Http/3 버전이 있음에도 Http/1.1 버전을 사용하는 이유는 우리가 필요로 하는 기본 스펙이 충분히 존재하기 때문이다.
-  Http/2, Http/3 버전은 아직 성능 개선에 초점이 맞춰져 있어서 1.1 버전을 사용해도 충분하다고 한다. 
-  참고로 ~ Http/2 버전까지는 TCP 기반, Http/3 버전은 TCP 대신 UDP를 사용하는 방안으로 개선 중이라 한다. 
-  즉, Http 프로토콜도 TCP 프로토콜을 기반으로 작동하는 것이기 때문에 1주차에서 배운 TCP/UDP 프로토콜 내용도 잘 복습해놔야 한다.


### 클라이언트 서버 구조
- Http 통신은 클라이언트에서 요청을 보내면 서버에서 응답을 보내는 방식으로 이루어진다. 
- 비즈니스 로직은 서버 개발에서 맡고, 클라이언트의 종류에 따라 UI 처리, api 응답 처리는 클라이언트 쪽에서 담당하면 된다. 즉, 역할을 분배하여 생산성이 높아진다.

### Stateful, Stateless
Http는 Stateless하다. Stateless는 무엇이고 Stateful하다는 것은 무엇일까?

- Stateful (상태유지) 예시
```
요청: 이 과자는 얼마입니까?
응답: 2,000원입니다.

요청: 3개 구매하겠습니다.
응답: 6,000원입니다. 할인카드 있으신가요?

요청: 멤버십 할인 있습니다.
응답: 10% 할인돼서 5,400원입니다. 감사합니다.
```

- Stateless(무상태) 예시
```
요청: 이 과자는 얼마입니까?
응답: 2,000원입니다.

요청: 3개 구매하겠습니다.
응답: ? 무엇을 3개 구매하실 건가요?

요청: 멤버십 할인 있습니다.
응답: ? 아 네 ^^.... (어쩌라는거지?)
```


- Http 통신에서는 응답이 바뀔 때 장애가 발생하지 않게 하기 위해 Stateless 선호.
- stateful 상태일 때는 상태를 유지하면서 그때그때 필요한 요청만 말함 -> 중간중간 응답이 바뀌면 응답의 입장에선 무얼 원하는지 알 수가 없다.
- Stateless 상태는 받은 응답을 바탕으로 필요정보를 모두 포함해서 요청을 보내주면 응답이 중간에 바뀌어도 통신이 가능해진다.

```
Stateless (무상태)
요청: 이 과자는 얼마입니까?
응답: 2,000원입니다.

요청: 이 과자를 3개 구매하겠습니다.
응답: 과자 3개는 6,000원입니다. 할인카드 있으신가요?

요청: 이 과자를 3개 구매하겠습니다. 멤버십 할인 있습니다.
응답: 과자 3개는 6,000원인데, 10% 할인돼서 5,400원입니다. 감사합니다.
```


- 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다. 
- 중간에 특정 서버 장애가 발생해도 대체하기 쉽다.
- 로그인 권한이 필요한 부분까지 Stateless하다면 우리는 매 요청을 할 때마다 새롭게 로그인을 해주어야 할 것이다. 이렇게 일부 최소한의 Stateful 상태유지는 필요하다. 
- 또한, 요청 측에서 데이터를 너무 많이 보내주어야 한다는 단점도 존재한다. 


### 비연결성(Connectionless)
- HTTP 프로토콜은 TCP 프로토콜을 기반으로 한다. 그런데 TCP는 연결지향성 프로토콜이다. 이쯤되면 의문이 하나 들 것이다. HTTP 프로토콜은 왜 Connectionless하다는 것일까?
- 바로 TCP 연결을 요청-응답 처리 후에 끊어버리기 때문이다. 
- 이렇게 하면 서버의 자원을 효율적으로 관리할 수 있게 된다.

- 매번 TCP/IP 연결을 새로 맺어야하므로 3 way handshake 시간이 그만큼 추가된다. 
- 또, 요즘은 이미지파일, js 파일 등 굉장히 많은 파일들이 존재하기 때문에 매번 연결을 끊고 다시 연결하는 경우엔 시간이 더더욱 오래 걸린다. 
- HTTP 지속 연결로 단점 보완. 모든 파일을 요청하자마자 바로 응답해주고, 완전히 처리가 완료됐으면 연결을 끊는 것이다. 

### HTTP 메시지 구조


- 시작 라인
  - 요청: HTTP method, 요청대상(절대경로[?쿼리]), Http Version
  - 응답: Http Version, Http StatusCode, 이유문구

- 헤더
  - 요청: URI
  - 응답: Content-Type, Content-Length
  - HTTP 전송에 필요한 부가정보 (html, css, xml인지, body의 크기라든지, 캐시 정보라든지, 압축 여부 등)들이 헤더에 들어가있다고 한다.

- 바디
  - 실제 전송할 데이터들이 들어가있다.

## 2. HTTP 메서드
HTTP API
- '/read-member-by-id', 'create-member' 과 같이 길지만 명확한 API를 좋다고 할 수 있을까? 
- URI가 지나치게 길어져 가독성이 떨어지고 유지보수에도 어려움을 겪게될 것이다.
- API 설계에서 가장 중요한 것은 리소스 식별
- 리소스가 같지만 행위가 다른 기능들을 분리해줄 때엔 HTTP Method를 이용

### GET
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 body에 담기보다는 쿼리 (@PathVariable, @RequestParam 등) 를 통해서 전달.
- body 에 데이터를 담는 것을 지원하지 않는 브라우저가 많다고 한다.

### POST
- 신규 리소스 등록
- 요청 데이터 처리
- 서버에 전달하고 싶은 데이터는 body에 담아줌
- 다른 메서드로 쓰이기 애매한 경우
- 응답 status code가 201 (Created)일 때가 많다. 
- 이 때, 응답의 헤더 Location에는 /members/100 과 같이 식별자 path가 담기게 된다.


- 단순 변경이라 생각하여 PUT이나 PATCH를 사용했지만, 실제로는 수많은 프로세스의 변경이 일어났다면 POST가 적절하다. 
- 예를 들어 주문상태를 '대기' -> '배달시작'으로 변경할 때, 주문상태뿐 아니라 배달기사님을 호출하고, 음식조리를 완료처리로 변경하고, 주문서를 변경하는 여러 작업이 들어갈 땐 POST가 적절할 수 있다.

### PUT
- 리소스를 완전히 대체
- 해당 리소스가 없으면 생성 (덮어쓰기)
- 클라이언트가 리소스 위치를 알고 있을 때


### PATCH
- 리소스 `부분 변경`


### DELETE
- 리소스 삭제
- 주로 삭제를 하기 때문에 응답 Http Status code로 204 (No Content)를 많이 보내.

### HTTP 메서드의 속성
- 안전: 호출해도 리소스를 변경하지 않는다. 
  - (GET)
- 멱등: 여러번 호출해도 동일한 결과를 보장한다.
  - (GET, PUT, DELETE)
  - PUT은 리소스를 대체한다. 덮어쓰는 행위이기 때문에 멱등성이 보장된다.
  - PATCH는 리소스를 수정한다. 만약 해당 리소스의 int값에 +=2를 하는 행위를 여러 번 한다면 결과는 매번 달라진다. 따라서 PATCH는 멱등성이 보장되지 않는다. 이는 POST도 마찬가지이다.
  - 이렇게 여러번 요청됐을 때 문제가 되는 행위를 기준으로 생각해보는 것도 좋다.
- 캐시가능: 응답 결과 리소스를 캐싱해서 사용해도 된다. 
  - (GET, POST, PATCH)
  - 실제로는 GET 관련에서만 캐싱을 사용한다고 한다. POST, PATCH는 응답 바디까지 캐싱 키로 고려를 해야 하는데, 이 과정이 쉽지 않다고 한다.
