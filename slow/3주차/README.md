# 3주차

### 클라이언트에서 서버로 데이터 전송 방법

- 쿼리 파라미터를 통한 데이터 전송
    - GET
    - 주로 정렬 필터(검색어)
- 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH
    - 회원 가입, 상품 주문, 리소스 등록, 리소스 변경

### 4가지 상황으로 보는 데이터 전송 방법

- 정적 데이터 조회
    - 이미지, 정적 텍스트 문서
    - 조회는 GET 사용
    - 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능
    - 서버는 이미지 리소스를 만들어서 클라이언트에게 전달
- 동적 데이터 조회
    - `https://www.google.com/search?q=hello&hl=ko`
    - 주로 검색, 게시판 목록에서 정렬 필터(검색어)
    - 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
    - 쿼리 파라미터 사용
- HTML Form을 통한 데이터 전송
    - 회원 가입, 상품 주문, 데이터 변경
    - GET, POST 만 지원
    - Content-Type: application/x-www-form-urlencoded (default)
        - POST 전송
            - Key-Value 형태로 전송
            - username=kim&age=20
        - GET 도 사용 가능 하지만(쿼리 파라미터로 들어 감), 리소스 변경이 발생하는 곳에서는 사용하면  안된다.
    - Content-Type: multipart/form-data
        - boundary를 기준으로 데이터를 나눠준다.
        - 바이너리 데이터 전송에 주로 사용
- HTTP API를 통한 데이터 전송
    - 회원 가입, 상품 주문, 데이터 변경
    - 서버 to 서버
        - 백엔드 시스템 통신
    - 앱 클라이언트
    - 웹 클라이언트
        - HTML Form 전송 대신 자바스크립트를 통한 통신에 사용(AJAX)
    - Content-Type: application/json 을 주로 사용 (사실상 표준)
        - XML에 비해서 상대적으로 크기가 작음

### [API 설계] POST - 신규 자원 등록

- 클라이언트는 등록될 리소스의 URI를 모른다. 단지 데이터를 서버에 전달한다.
- 서버가 새로 등록된 리소스 URI를 생성해준다.
    - HTTP/1.1 201 Created
    - Location: /members/100
- 컬렉션
    - 서버가 관리하는 리소스 디렉토리
    - 서버가 리소스의 URI를 생성하고 관리
    - 여기서 컬렉션은 /memebers
    

### [API 설계] PUT 기반 신규 자원 등록

- 클라이언트가 리소스 URI를 알고 있어야 한다.
    - 파일 등록 /files/{filename}
    - PUT /files/start.jpg
- 클라이언트가 직접 리소스의 URI를 지정한다.
- 스토어
    - 클라이언트가 관리하는 리소스 저장소
    - 클라이언트가 리소스의 URI를 알고 분리

### HTML FORM 사용

- 등록 폼과 등록을 1대1로 같은 URI를 사용하는 것을 선호
    - validation 오류가 발생해서 등록 폼을 다시 보내야하는 경우, 경로가 같으면 바꿀 필요 없이 해결 가능. 반대의 경우 리프레쉬해서 다시 등록 폼으로 돌아갈 수 없음
- GET, POST만 사용할 수 있다는 제약을 해결하기 위해서 컨트롤 URI 사용
    - 최대한 리소스라는 개념을 가지고 API를 설계하고, 그 상황에서 안될 때 대체제로 사용한다.

### URI 설계 개념

- 문서(document)
    - 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
    - /members/100, /files/star.jpg
- 컬렉션(collection)
    - 서버기 관리하는 리소스 디렉터리
    - 서버가 리소스의 URI를 생성하고 관리
- 스토어(store)
    - 클라이언트가 관리하는 자원 저장소
    - 클라이언트가 리소스의 URI를 알고 관리
    - /files
- 컨트롤러(controller), 컨트롤 URI
    - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    - 데이터를 조작하거나 변경하는 일
    - 동사를 직접 사용
    - /members/{Id}/delete

## HTTP 상태 코드

: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

```java
- 1xx (Informational): 요청이 수신되어 처리중
- 2xx (Successful): 요청 정상 처리
- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
- 4xx (Client Error): 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
```

### 만약 모르는 상태 코드가 나타나면?

- 상위 상태 코드로 이해하고 처리하면 됨.

### 1xx (Informational)

요청이 수신되어 처리 중

- 거의 사용하지 않음

### 2xx (Successful)

클라이언트의 요청을 성공적으로 처리

- 200 OK
    - 요청 성공
- 201 Created
    - 요청 성공해서 새로운 리소스가 생성됨
    - 생성된 리소스는 응답의 `Location` 헤더 필드로 식별
    
    ```java
    ResponseEntity.*created(*URI.*create(*"/lines/" + lineResponse.getId*()))*.body*(*lineResponse*)*
    ```
    
- 202 Accepted
    - 요청이 접수되었으나 처리가 완료되지 않았음
    - 배치 처리 같은 곳에서 사용
        - ex) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함
- 204 No Content
    - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
    - ex) 웹 문서 편집기에서 save 버튼
    - 편집하고 save 누를 때마다 해당 본문을 받을 필요는 없다.
    - save 눌러도 같은 화면을 유지해야 한다.
    - 결과 내용이 없어도

### 3xx (Redirection)

요청을 완료하기 위해 유저 에이전트의 추가 조치 필요

3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)

### 영구 리다이렉션

- 리소스의 URI가 영구적으로 이동
- 원래의 URL를 사용 X, 검색 엔진 등에서도 변경 인지
- 301 Moved Permanently
    - 리다이렉트시, 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
- 308 Permanent Redirect
    - 301과 기능은 같음
    - 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST 유지)

### 일시 리다이렉션

리소스의 URI가 일시적으로 변경. 따라서 검색 엔진 등에서 URL을 변경하면 안됨

- 302 Found
    - 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거돌 수 있음(MAY)
- 307 temporary Redirect
    - 302와 기능은 같음
    - 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT)
- 303 See Other
    - 302화 기능은 같음
    - 리다이렉트시 요청 메서드가 GET으로 변경

### 일시적인 리다이렉션 언제 사용할까?

- PRG 사용 전
    - POST로 주문후에 웹 브라우저를 새로고침하면?
    - 새로고침은 다시 요청
    - 따라서, 중복 주문이 될 수 있다.
    
- PRG: Post/Redirect/Get
    - POST로 주문후에 새로 고침으로 인한 중복 주문 방지
    - POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
    - 새로고침 해도 GET으로 결과 화면만 을 조회
    

### 그래서 뭘 써야 하나?

- 처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것. 그런데 웹 브라우저들이 대부분 GET으로 바뀜.
- 그래서 모호한 302를 대신하는 307, 303 등장
- 307, 303을 권장하지만 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 많이 사용
- 자동 리다이렉션시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음

### 기타 리다이렉션

- 300 Multiple Choices
    - 안씀
- 304 Not Modified
    - 캐시를 목적으로 사용
    - 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이어느는 로컬PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
    - 304 응답 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)
    - 조전부 GET, HEAD 요청시 사용

### 4xx (Client Error)

클라이언트 오류

- 클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없음
- 오류의 원인이 클라이언트에 있음
- 클라이언트가 이미 잘못된 요청 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함
    - 반면, 500대 오류는 DB 장애로 오류가 발생했다가 DB가 복구되면 클라이언트가 똑같은 요청을 재시도 했을 때 요청이 성공할 가능성이 있다.
- 400 Bad Request
    - 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
    - 요청 구문, 메시지 등등 오류
    - 클라이언트는 요청 내용을 다시 검토하고 보내야함
        - ex) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때
- 401 Unauthorized
    - 클라이언트가 해당 리소스에 대한 인증이 필요함
    - 인증(Authentication) 되지 않음
    - 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
    - 참고
        - 인증(Authentication) : 본인이 누구인지 확인, (로그인)
        - 인가(Authorization): 권한 부여 (Admin 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있음)
        - 오류 메시지가 Unauthorized이지만, 인증되지 않음.
- 403 Forbidden
    - 서버가 요청을 이해했지만 승인을 거부함
    - 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
    - ex) 어드민 등급이 아닌 사용자가 로그인은 했지만, 어드민 등급의 리소스에 접근하는 경우
- 404 Not Found
    - 요청 리소스를 찾을 수 없음
    - 요청 리소스가 서버에 없음
    - 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때

### 5xx (Server Error)

서버 오류

- 서버 문제로 오류 발생
- 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있음(DB가 복구 되거나 등등)

- 500 Internal Server Error
    - 서버 문제로 오류 발생, 애매하면 500 오류
    - 서버 내부 문제로 오류 발생
    - 애매하면 500 오류
- 503 Service Unavailable
    - 서비스 이용 불가
    - 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
    - Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음